module Observer = Signals__Observer

// Observer registry: observer ID → Observer.t (mutable)
let observers: Map.t<int, Observer.t> = Map.make()

// Bidirectional index: signal ID → set of observer IDs (mutable)
let signalObservers: Map.t<int, Set.t<int>> = Map.make()

// Computed tracking: signal ID → observer ID (mutable)
let computedToObserver: Map.t<int, int> = Map.make()

// Current execution context (which observer is running)
let currentObserverId: ref<option<int>> = ref(None)

let pending: Set.t<int> = Set.make()
let flushing: ref<bool> = ref(false)
let retracking: ref<bool> = ref(false)

// Queue for iterative dirty marking (avoids stack overflow from recursion)
let dirtyQueue: array<int> = []

module SignalObservers = {
  let ensure = (signalId: int): unit => {
    switch signalObservers->Map.get(signalId) {
    | Some(_) => ()
    | None => signalObservers->Map.set(signalId, Set.make())
    }
  }

  let forEach = (signalId: int, fn: int => unit): unit => {
    switch signalObservers->Map.get(signalId) {
    | Some(obsSet) => obsSet->Set.forEach(fn)
    | None => ()
    }
  }

  let add = (signalId: int, observerId: int): unit => {
    switch signalObservers->Map.get(signalId) {
    | Some(obsSet) => obsSet->Set.add(observerId)
    | None => ()
    }
  }

  let remove = (signalId: int, observerId: int): unit => {
    switch signalObservers->Map.get(signalId) {
    | Some(obsSet) => obsSet->Set.delete(observerId)->ignore
    | None => ()
    }
  }

  let toArray = (signalId: int): array<int> => {
    signalObservers
    ->Map.get(signalId)
    ->Option.getOr(Set.make())
    ->Set.values
    ->Core__Iterator.toArray
  }
}

module ExecutionContext = {
  let withContext = (observerId: int, fn: unit => 'a): 'a => {
    let prev = currentObserverId.contents
    currentObserverId := Some(observerId)
    try {
      let result = fn()
      currentObserverId := prev
      result
    } catch {
    | exn => {
        currentObserverId := prev
        throw(exn)
      }
    }
  }

  let withoutTracking = (fn: unit => 'a): 'a => {
    let prev = currentObserverId.contents
    currentObserverId := None
    try {
      let result = fn()
      currentObserverId := prev
      result
    } catch {
    | exn => {
        currentObserverId := prev
        throw(exn)
      }
    }
  }

  let isCurrentObserver = (observerId: int): bool => {
    switch currentObserverId.contents {
    | Some(currentId) => currentId == observerId
    | None => false
    }
  }
}

module FlushGuard = {
  let withFlushing = (fn: unit => unit): unit => {
    if !flushing.contents {
      flushing := true
      try {
        fn()
        flushing := false
      } catch {
      | exn => {
          flushing := false
          throw(exn)
        }
      }
    }
  }
}

// Fast path addDep - called from Signal.get when we know observerId is current
let addDep = (observerId: int, signalId: int): unit => {
  // Only do work if this is actually a new dependency
  switch observers->Map.get(observerId) {
  | Some(observer) =>
    if !(observer.deps->Set.has(signalId)) {
      observer.deps->Set.add(signalId)
      // Ensure signal has observer set and add to it
      SignalObservers.ensure(signalId)
      SignalObservers.add(signalId, observerId)
    }
  | None => ()
  }
}

let rec clearDeps = (observer: Observer.t): unit => {
  observer.deps->Set.forEach(signalId => SignalObservers.remove(signalId, observer.id))
  Set.clear(observer.deps)
}

and autoDisposeComputed = (signalId: int): unit => {
  switch computedToObserver->Map.get(signalId) {
  | Some(observerId) => {
      computedToObserver->Map.delete(signalId)->ignore
      switch observers->Map.get(observerId) {
      | Some(obs) => {
          clearDeps(obs)
          observers->Map.delete(observerId)->ignore
        }
      | None => ()
      }
    }
  | None => ()
  }
}

module LevelCalculation = {
  let forEffect = (observer: Observer.t): int => {
    // Effects run after all computeds
    // Only look at computed observers, not other effects, to prevent level inflation
    // Use mutable ref instead of allocating array
    let maxLevel = ref(0)

    observer.deps->Set.forEach(signalId => {
      SignalObservers.forEach(signalId, depObsId => {
        if depObsId != observer.id {
          switch observers->Map.get(depObsId) {
          | Some(depObs) =>
            switch depObs.kind {
            | #Computed(_) =>
              if depObs.level > maxLevel.contents {
                maxLevel := depObs.level
              }
            | #Effect => () // Ignore effects to prevent level inflation
            }
          | None => ()
          }
        }
      })
    })

    maxLevel.contents + 1
  }

  let forComputed = (observer: Observer.t): int => {
    // Computeds run based on dependency depth
    // Track producer→consumer edges directly by checking if dependencies are computed signals
    // Use mutable ref instead of allocating array
    let maxLevel = ref(0)

    observer.deps->Set.forEach(signalId => {
      switch computedToObserver->Map.get(signalId) {
      | Some(producerObsId) if producerObsId != observer.id =>
        switch observers->Map.get(producerObsId) {
        | Some(producerObs) =>
          if producerObs.level > maxLevel.contents {
            maxLevel := producerObs.level
          }
        | None => ()
        }
      | _ => ()
      }
    })

    maxLevel.contents + 1
  }
}

let computeLevel = (observer: Observer.t): int => {
  switch observer.kind {
  | #Effect => LevelCalculation.forEffect(observer)
  | #Computed(_) => LevelCalculation.forComputed(observer)
  }
}

module ObserverExecution = {
  // Compare observers directly by level (no Map lookups needed)
  let compareByLevel = (a: Observer.t, b: Observer.t): float => {
    Int.toFloat(a.level - b.level)
  }

  let retrack = (observer: Observer.t): unit => {
    retracking := true
    clearDeps(observer)

    ExecutionContext.withContext(observer.id, () => {
      observer.run()
      retracking := false
    })

    observer.level = computeLevel(observer)
  }
}

let anyPending = () => pending->Set.size > 0

// Pre-allocated arrays for flush to avoid repeated allocations
let pendingComputeds: array<Observer.t> = []
let pendingEffects: array<Observer.t> = []

// Efficient array clear (sets length to 0, no allocation)
let clearArray: array<'a> => unit = %raw(`function(arr) { arr.length = 0 }`)

let flush = (): unit => {
  while anyPending() {
    // Clear reusable arrays efficiently
    clearArray(pendingComputeds)
    clearArray(pendingEffects)

    // Single pass: collect and separate observers (N lookups instead of N log N)
    pending->Set.forEach(observerId => {
      switch observers->Map.get(observerId) {
      | Some(observer) =>
        switch observer.kind {
        | #Computed(_) => pendingComputeds->Array.push(observer)->ignore
        | #Effect => pendingEffects->Array.push(observer)->ignore
        }
      | None => ()
      }
    })
    Set.clear(pending)

    // Sort by level only (no Map lookups in comparator)
    pendingComputeds->Array.sort(ObserverExecution.compareByLevel)->ignore
    pendingEffects->Array.sort(ObserverExecution.compareByLevel)->ignore

    // Execute computeds first, then effects
    pendingComputeds->Array.forEach(ObserverExecution.retrack)
    pendingEffects->Array.forEach(ObserverExecution.retrack)
  }
}

let schedule = (observerId: int): unit => {
  pending->Set.add(observerId)
  FlushGuard.withFlushing(flush)
}

// Iterative notify - avoids stack overflow on deep computed chains
let notify = (signalId: int): unit => {
  // Seed the queue with the initial signal
  dirtyQueue->Array.push(signalId)->ignore

  // Process all signals iteratively
  while dirtyQueue->Array.length > 0 {
    let currentSignalId = dirtyQueue->Array.pop
    switch currentSignalId {
    | None => ()
    | Some(sid) =>
      SignalObservers.forEach(sid, observerId => {
        switch observers->Map.get(observerId) {
        | None => ()
        | Some(observer) =>
          switch observer.kind {
          | #Effect => pending->Set.add(observerId)
          | #Computed(backingSignalId) =>
            if !observer.dirty {
              observer.dirty = true
              dirtyQueue->Array.push(backingSignalId)->ignore
            }
          }
        }
      })
    }
  }

  // Trigger flush only once after all dirty marking is complete
  if anyPending() {
    FlushGuard.withFlushing(flush)
  }
}

let ensureComputedFresh = (signalId: int): unit => {
  switch computedToObserver->Map.get(signalId) {
  | Some(observerId) =>
    switch observers->Map.get(observerId) {
    | Some(observer) =>
      if observer.dirty {
        retracking := true
        clearDeps(observer)

        ExecutionContext.withContext(observerId, () => {
          observer.run()
          observer.dirty = false
          retracking := false
        })

        observer.level = computeLevel(observer)
      }
    | None => ()
    }
  | None => ()
  }
}

let batch = fn => {
  let wasFlushing = flushing.contents
  flushing := true

  try {
    let result = fn()
    if !wasFlushing {
      flushing := false
      if anyPending() {
        flush()
      }
    }
    result
  } catch {
  | exn => {
      if !wasFlushing {
        flushing := false
      }
      throw(exn)
    }
  }
}

let untrack = ExecutionContext.withoutTracking
let ensureSignal = SignalObservers.ensure
